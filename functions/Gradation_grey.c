#include "header.h"


/**
 * @brief Перевод цветного изображения в градации серого.
 * 
 * Функция преобразует изображение в полутоновое (оттенки серого), усредняя значения всех каналов
 * для каждого пикселя. Количество каналов при этом сохраняется — каждый канал получает одинаковое значение.
 * 
 * @param input_file Путь к исходному цветному изображению.
 * @param output_file Путь для сохранения изображения в градациях серого.
 * 
 * @return int Код возврата: 0 — успешно, 666 — ошибка чтения изображения.
 * 
 * @note В результате обработки сохраняется исходное количество каналов, но каждый канал пикселя содержит одно и то же значение.
 *       Это позволяет сохранить совместимость с дальнейшей обработкой, ожидающей те же размеры данных.
 * 
 * @warning Убедитесь, что изображение доступно и путь указан корректно.
 */


// перевод цветного изображения в градацию серого (кол-во каналов неизменно)
int Gradation_grey (char* input_file, char* output_file) {
     // ширина узображения в пикселях
    int width;
     // высота
    int height;
     // кол-во каналов
    int channels;
    // картинка в массив цветов
    uc* image     = stbi_load(input_file, &width, &height, &channels, 0);
    // проверка на правильность чтения файла
    if (image == NULL) {
        printf("============= ERROR READ PICTURE =============\n");
        return 666;
    }
    // массив для измененной картинки
    uc* new_image = (uc*)calloc(width * height * channels, sizeof(uc));
    // счетчик индекса
    int ind0 = 0;
    // по высоте
    for (int i = 0; i < height; i++) {
        // по ширине
        for (int j = 0; j < width; j++) {
            // итоговая сумма
            int sum = 0;
            // по каналам
            for (int ch = 0; ch < channels; ch++) {
                // для удобства записи
                int ind1 = (i*width + j) * channels + ch;
                // увеличиваем сумму
                sum += image[ind0];
            }
            // снова проходим по каналам
            for (int ch = 0; ch < channels; ch++) {
                // записываем среднее арифметическое
                new_image[ind0++] = sum / channels;
            }
        }
    }
    stbi_write_jpg(output_file, width, height, channels, new_image, 100);
    // чистка памяти
    stbi_image_free(image);
    free(new_image);
    return 0;
}
